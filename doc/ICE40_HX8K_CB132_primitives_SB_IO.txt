

---------------------------
SB_IO  entity
---------------------------

entity  SB_IO is

   generic (
           NEG_TRIGGER : bit                       :=  '0';         invert clock
           PIN_TYPE    : bit_vector (5 downto 0)   :=  "000000";    (see below)
           PULLUP      : bit                       :=  '0';         enable pullup
           IO_STANDARD : string                    :=  "SB_LVCMOS"  define standard
           );
   port 
       (
       D_OUT_1             : in std_logic;         output data 1
       D_OUT_0             : in std_logic;         output data 0
       CLOCK_ENABLE        : in std_logic;         clock enable
       LATCH_INPUT_VALUE   : in std_logic;         latch input value
       INPUT_CLK           : in std_logic;         input clock
       D_IN_1              : out std_logic;        input data 1
       D_IN_0              : out std_logic;        input data 0
       OUTPUT_ENABLE       : in std_logic  :='H';  output enable
       OUTPUT_CLK          : in std_logic;         output clock
       PACKAGE_PIN         : inout std_ulogic      IO pin signal name
       ); 
        
end SB_IO ;

---------------------------

PINTYPE 00 00 00
        || || ||
        54 32 10 (bits)

PINTYPE binary string can be split in 3 groups of two bits.
bits 5,4,3,2 determines the output type
(5,4 determine the enabling mode and 3,2 the output mode)
bits 1,0 determines the input type

---------------------------

INPUT TYPE: 

   bit 0 enables registering the input data
   bit 1 enables latching the input data

check bit 1, 0 values:

- case 0, 1 : "simple input"
   
 D_IN_0 is a copy of PACKAGE_PIN

- case 1, 1 : "input latch"

 when LATCH_INPUT_VALUE = 0: D_IN_0 is a copy of PACKAGE_PIN 
 when LATCH_INPUT_VALUE = 1: the value of D_IN_0 held indefinitely

- case 0, 0 : "input registered"

 D_IN_0 is the last value of PACKAGE_PIN after the last INPUT_CLK rising edge

- case 1, 0 : "input registered and latched"

 when LATCH_INPUT_VALUE = 0: D_IN_0 is a copy of the input registered
 when LATCH_INPUT_VALUE = 1: the value of D_IN_0 is held indefinitely

- in all cases: 
  D_IN_1 is a copy of PACKAGE_PIN after the last INPUT_CLK falling edge. This is used for the DDR mode.

INPUT_CLK is only active if CLOCK_ENABLE is high.

---------------------------

OUTPUT TYPE: 

A) Enabling mode:
   bit 5 enables the OUTPUT_ENABLE signal
   bit 4 selects the output mode or select the synchronisation

check bit 5, 4 values:

- case 0, 0: output always on high impedance.
- case 0, 1: output always enabled.
- case 1, 0: use OUTPUT_ENABLE asynchronously
- case 1, 1: use OUTPUT_ENABLE synchronously with the rising edge of OUTPUT_CLK

B) Output mode:

check bit 3, 2 values:

- case 1, 0: output signal is a copy of D_OUT_0
- case 0, 1: output signal is the registered value of D_OUT_0 (rising edge)
- case 1, 1: output signal is the inverted registered value of D_OUT_0 (rising edge)
- case 1, 0: output signal is alternatively the registered value of D_OUT_0 (rising edge) and the registered value of D_OUT_1 (falling edge). this is the DDR mode.

OUTPUT_CLK is only active if CLOCK_ENABLE is high.

---------------------------

EXAMPLE:

-- declare library

library sb_ice40_components_syn;
use sb_ice40_components_syn.components.all;

-- instantiate component using name "sbio_inst" as a simple output

    sbio_inst : SB_IO

        generic map (
            NEG_TRIGGER     => '0',
            PIN_TYPE        => "011001",
            PULLUP          => '0',
            IO_STANDARD     => "SB_LVCMOS"
        )
        
        port map (
            D_OUT_1             => '0',
            D_OUT_0             => counter(24),
            CLOCK_ENABLE        => '0',
            LATCH_INPUT_VALUE   => '0',
            INPUT_CLK           => AlCu_CLOCK, 
            D_IN_1              => open,
            D_IN_0              => open,
            OUTPUT_ENABLE       => '0',
            OUTPUT_CLK          => '0',
            PACKAGE_PIN         => AlIo_LED01
        ); 
